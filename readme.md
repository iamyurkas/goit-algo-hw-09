# Порівняння ефективності жадібного алгоритму та алгоритму динамічного програмування

## Результати виконання для суми 18 888

| Алгоритм                | Результат                             | Час виконання (секунди) |
| ----------------------- | ------------------------------------- | ----------------------- |
| Жадібний алгоритм       | `{50: 377, 25: 1, 10: 1, 2: 1, 1: 1}` | 0.000006                |
| Динамічне програмування | `{50: 377, 25: 1, 10: 1, 2: 1, 1: 1}` | 0.009691                |

---

## Аналіз продуктивності

- **Жадібний алгоритм** працює надзвичайно швидко (6 мікросекунд).  
  Він просто послідовно перебирає доступні монети від найбільшої до найменшої, використовуючи максимальну можливу кількість кожної монети.

- **Алгоритм динамічного програмування** виконується значно повільніше (приблизно 9,7 мілісекунди).  
  Він будує таблицю розміром `сума + 1` (тобто 18 889 елементів), для кожного значення обчислюючи мінімальну кількість монет.

---

## Висновки

- **Жадібний алгоритм** є надзвичайно ефективним при великих сумах, особливо коли:

  - Набір монет добре підібраний (як у прикладі — кожен менший номінал добре доповнює більший).
  - Жадібний вибір завжди веде до оптимального рішення.

- **Алгоритм динамічного програмування** гарантує мінімальну кількість монет у загальному випадку, навіть коли:

  - Набір монет "поганий" для жадібного підходу (наприклад, монети `[9, 6, 1]` можуть спричинити неправильне рішення жадібним методом).
  - Потрібна максимальна оптимальність незалежно від структури номіналів.

- Для **звичайних касових апаратів** і стандартних монет (як у прикладі) краще використовувати **жадібний алгоритм** через його блискавичну швидкість і простоту.

- Для **нестандартних наборів монет** або **особливих вимог до мінімізації кількості монет** доцільно застосовувати **динамічне програмування**, попри вищі витрати часу та пам'яті.

---
